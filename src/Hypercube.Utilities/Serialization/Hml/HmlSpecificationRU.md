# **Обзор**
**HML (Hypercube Markup Language)** — декларативный язык описания данных, основанный на минималистичном синтаксисе и строгой типизации.
Он предназначен для сериализации и обмена структурированными данными в формате, удобном как для человека, так и для машины.

# **Конструкции**

## **Идентификатор**

Идентификатор — символьная последовательность, предназначенная для обозначения элемента, поля или свойства объекта.

### **Правила**
1. Первый символ **не может быть цифрой**.
2. Идентификаторы **чувствительны к регистру**.
3. Запрещено использовать **зарезервированные символы** (`{}`, `[]`, `:`, `;`, `$`, `"`, и т. д.) в качестве части идентификатора.

### **Примеры**
```yaml
name
UserID
_config
HelloWorld
```

## **Значение**
Значением может быть **любой допустимый тип данных**, включая примитивы, коллекции и специальные конструкции.
Значение присваивается идентификатору с помощью двоеточия `:`.
Значение должно заканчиваться точкой с запятой `;`, либо переносом строки.

```yaml
field1: "Hello"
field2: 123;
```

# **Типы данных**

## **Примитивы**

### **Число (Number)**
Представляет целые и вещественные числа в различных системах счисления.

**Целые числа:** `100`, `189` </br>
**Вещественные числа:** `1.0`, `10.52` </br>
**Двоичная запись:** `0b1` (равносильная запись `1`), `0b1011` (равносильная запись `11`) </br>
**Шеснацеричная запись:** `0xF5B6` (равносильная запись `62902`) </br>
**Экспоненциальная запись:** `1.5e-4` (равносильная запись `0.00015`), `1e3` (равносильная запись `1000`)

### **Строка (String)**

Представляет последовательность символов в двойных или одинарных кавычках `"..."` или многострочный текст в тройных `"""..."""`.

**Обычная строка:** `"Hello"`, `'Hypercube'` </br>
**Многострочная строка:**
```yaml
"""
First line
Second line
"""
```

### **Булево значение (Boolean)**
Представляет логическое состояние.

```yaml
true
false
```

### **Отсутствие значения (Null)**
Представляет отсутствие значения.
Часто используется при сериализации шаблонов.

```yaml
null
```

### **Перечисление (Enum)**
Перечисления используются для представления **предопределённых констант**,
которые задаются заранее разработчиком при работе с сериализатором.
Встроенных перечислений в HML нет.

**Синтаксис:** `$ИмяПеречисления.Элемент`

**Примеры:**
```yaml
$LogLevel.Info
$Color.Red
```

**Особенности:**
1. Перечисления могут быть любым типом данных, в зависимости от того, как их определил разработчик.
2. Над числовыми перечислениями разрешены все стандартные математические и побитовые операции:

```yaml
$Flags.Read | $Flags.Write   // Побитовое ИЛИ
$Flags.Execute & $Flags.All  // Побитовое И
$Level.High + 2              // Арифметика
```

3. Значения перечислений всегда фиксируются сериализатором и не меняются динамически во время выполнения HML-файла.

## **Коллекции**

### **Объект (Object)**
Набор уникальных пар *идентификатор–значение* в фигурных скобках `{}`.
Каждое поле отделяется точкой с запятой `;`.

**Пример многострочной записи объекта:**
```yaml
{
  name: "Hypercube"
  version: 1.0
  stable: true
}
```

**Пример однострочной записи объекта:**
```yaml
{ name: 'Hypercube'; version: '1.0'; stable: true }
```


### **Словарь (Dictionary)**
Коллекция произвольных пар *ключ–значение*, где и ключ, и значение могут быть любого типа.
Каждая пара отделяется точкой с запятой `;`.
Ключи уникальны в пределах словаря.

> [!IMPORTANT]
> *Прмиерчание:* ключ может быть оформлен как индефикатор,
> но в контексте словаря, данная запись будет эквивалента типу строка.

**Пример многострочной записи словаря:**
```yaml
[
  'Hi': 'World'
  1: 0
  true: false // равносильно 'true': false
  null: null  // равносильно 'null': null
  $LogLevel.Info: 'Informational'
]
```

**Пример однострочной записи объекта:**
```yaml
[ 'Hi': 'World'; 1: 0; true: false; null: null; $LogLevel.Info: 'Informational' ]
```

### **Список (List)**
Упорядоченная коллекция значений.
Элементы отделяются точкой с запятой `;`.

**Пример многострочной записи списка:**
```yaml
[
  'World'
  0
  false
  null
  [
    'key1'
    'ac'
  ]
  ['key2'; 'ab']
]
```

**Пример однострочной записи объекта:**
```yaml
[ 'World'; 0; false; null; [ 'key1'; 'ac' ]; ['key2'; 'ab'] ]
```

## **Специальные типы**

### **Неизвестность (Unknown)**
Обозначает отсутствие известного типа данных или недоопределённость структуры.
Может возникать при вводе нераспознанных символов, не принадлежащих никакому типу.

**Примеры:**

```yaml
Unknown?
???
Hello World!
?123!;
```


# **Ключевые слова и символы**

## **Ключевые слова**
В HML есть несколько зарезервированных слов, которые имеют специальное значение и **могут** использоваться как идентификаторы:

| Слово     | Значение                 |
| --------- | ------------------------ |
| `true`    | Булево значение "истина" |
| `false`   | Булево значение "ложь"   |
| `null`    | Отсутствие значения      |
| `unknown` | Неизвестный тип данных   |


## **Зарезервированные символы**
Следующие символы нельзя использовать в идентификаторах, так как они служат для синтаксиса HML:

| Символ | Значение                               |
| ------ | -------------------------------------- |
| `-`    | Разделитель/специальный символ         |
| `{`    | Начало объекта                         |
| `}`    | Конец объекта                          |
| `[`    | Начало списка/словаря                  |
| `]`    | Конец списка/словаря                   |
| `<`    | Начало определителя типа               |
| `>`    | Конец определителя типа                |
| `$`    | Обозначение использования перечисления |
| `'`    | Ограничитель строк                     |
| `"`    | Ограничитель строк                     |
| `(`    | Начало выражения                       |
| `)`    | Конец выражения                        |

Эти символы можно использовать только в контексте их синтаксической роли.

## **Коментарии**
В HML поддерживаются однострочные и многострочные комментарии:

| Выражение | Тип комментария                   |
| --------- | --------------------------------- |
| `//`      | Однострочный комментарий          |
| `/*`      | Начало многострочного комментария |
| `*/`      | Конец многострочного комментария  |

## **Математические операции**
В HML поддерживаются стандартные арифметические операции над числами:

| Символ | Значение             | Пример         |
| ------ | -------------------- | -------------- |
| `+`    | Сложение             | `5 + 3` → `8`  |
| `-`    | Вычитание            | `5 - 3` → `2`  |
| `*`    | Умножение            | `5 * 3` → `15` |
| `/`    | Деление              | `6 / 3` → `2`  |
| `%`    | Остаток от деления   | `5 % 3` → `2`  |
| `**`   | Возведение в степень | `2 ** 3` → `8` |


## **Побитовые операции**
Побитовые операции работают с числами на уровне их бинарного представления:

| Символ | Значение                  | Пример                    |
| ------ | ------------------------- | ------------------------- |
| `&`    | Побитовое И (AND)         | `5 & 3` → `1`             |
| `\|`   | Побитовое ИЛИ (OR)        | `5 \| 3` → `7`            |
| `^`    | Побитовое Искл. ИЛИ (XOR) | `5 ^ 3` → `6`             |
| `~`    | Побитовое НЕ (NOT)        | `~5` → `-6`               |
| `<<`   | Сдвиг влево               | `5 << 1` → `10`           |
| `>>`   | Сдвиг вправо              | `5 >> 1` → `2`            |
| `>>>`  | Логический сдвиг вправо   | `-5 >>> 1` → `2147483645` |

# Математические и логические выражения
В HML поддержка математических и логических выражений реализована на уровне препроцессора,
а не самого интерпретатора языка.
Это значит, что перед тем как HML-файл будет десериализован,
все арифметические и побитовые операции вычисляются заранее,
и результат подставляется в структуру данных.

Например, запись:
```yaml
offset: 1 / 10 * 2, 5
```

Cначала проходит через препроцессор
и результат выражение подставляется на место операции:
```yaml
offset: 0.2, 5
```

После этого десериализатор видит невыражаемую в стандартных типах структуру (в данном случае `0.2, 5`)
и присваивает ей тип `unknown`, сохраняя фактическое значение как строку.
Так, что в значение типа `unknown` попадет результат выражения, а не само выражение.

# Явное указание типа
HML поддерживает конструкцию `<type>`, которая позволяет явно указать тип значения.

**Синтаксис:** `<тип> значение`

**Описание:**
- Тип — имя типа, используемого для интерпретации значения.
- Значение — данные, которые необходимо интерпретировать как указанный тип.
- Если значение не соответствует типу, оно сохраняется как `unknown` с явной меткой типа.

**Примеры:**
```yaml
num: <number> 1 / 10 * 2        // Явное указание не требуется т.к. 0.2 уже тип данных number
shape: <Rect2> { size: 10, 10 } // Тип будет unknown с меткой <Rect2> и значением объекта
color: <Color> 0xffffff         // Тип будет unknown с меткой <Color> и значением 16777215
```

# Комплексный пример

```
/*
* Типов данных Vector2 и Color по умолчанию не сущществует в HML
* При десириализации вы получите unknown с значием ввиде строки 
* С целью потдержки своих типов и был создан unknown 
*/
{
  type: entity
  name: test entity
  components: [
    transfrom: {
      position: 10, 5 // Значение поля будет unknown ('10, 5')
      scale: 1, 1
    }
    rigibody2d: {
      layer: $Layers.Imppassible | $Layers.Opaque
      shape: <Rect2> {
        size: 10, 10
      }
    }
    sprite: {
      texture: '/resources/textures/test.png'
      color: #ffffff

      // Значение поля будет unknown ('0.1875, -0.3125')
      offset: 1 / 16 * 3, 1 / 16 * -5
    }
    damage: { value: 5; type: $DamageType.Fire }
    ability: {
      key: <char> 'A'
    }
  ]
}
```